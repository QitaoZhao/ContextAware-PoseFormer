import os
import collections
from collections import defaultdict
from time import time
import pickle
import h5py
import random

import numpy as np
np.set_printoptions(suppress=True)
import cv2

import torch
from torch.utils.data import Dataset

from mvn.models.loss import MPJPE, P_MPJPE, N_MPJPE, MPJVE
from mvn.utils.multiview import Camera, project_3d_points_to_image_plane_without_distortion
from mvn.utils.img import get_square_bbox, resize_image, crop_image, normalize_image, scale_bbox, erase_image
from mvn.utils import volumetric

retval = {
    'subject_names': ['S1', 'S5', 'S6', 'S7', 'S8', 'S9', 'S11'],
    'camera_names': ['54138969', '55011271', '58860488', '60457274'],
    'action_names': [
        'Directions-1', 'Directions-2',
        'Discussion-1', 'Discussion-2',
        'Eating-1', 'Eating-2',
        'Greeting-1', 'Greeting-2',
        'Phoning-1', 'Phoning-2',
        'Posing-1', 'Posing-2',
        'Purchases-1', 'Purchases-2',
        'Sitting-1', 'Sitting-2',
        'SittingDown-1', 'SittingDown-2',
        'Smoking-1', 'Smoking-2',
        'TakingPhoto-1', 'TakingPhoto-2',
        'Waiting-1', 'Waiting-2',
        'Walking-1', 'Walking-2',
        'WalkingDog-1', 'WalkingDog-2',
        'WalkingTogether-1', 'WalkingTogether-2']
}

joints_left = [4, 5, 6, 11, 12, 13] 
joints_right = [1, 2, 3, 14, 15, 16]

class Human36MKeypointDataset(Dataset):
    """
        Human3.6M for multiview tasks.
    """
    def __init__(self,
                 root='/Vol1/dbstore/datasets/Human3.6M/processed/',
                 labels_path='/Vol1/dbstore/datasets/Human3.6M/extra/human36m-multiview-labels-SSDbboxes.npy',
                 pred_results_path=None,
                 image_shape=(192, 256),
                 train=False,
                 test=False,
                 retain_every_n_frames_in_test=1,
                 with_damaged_actions=False,
                 cuboid_size=2000.0,
                 scale_bbox=1.5,
                 norm_image=True,
                 kind="mpii",
                 undistort_images=False,
                 ignore_cameras=[],
                 crop=True,
                 subject = None
                 ):
        """
            root:
                Path to 'processed/' directory in Human3.6M
            labels_path:
                Path to 'human36m-multiview-labels.npy' generated by 'generate-labels-npy-multiview.py'
                from https://github.sec.samsung.net/RRU8-VIOLET/human36m-preprocessing
            retain_every_n_frames_in_test:
                By default, there are 159 181 frames in training set and 26 634 in test (val) set.
                With this parameter, test set frames will be evenly skipped frames so that the
                test set size is `26634 // retain_every_n_frames_in_test`.
                Use a value of 13 to get 2049 frames in test set.
            with_damaged_actions:
                If `True`, will include 'S9/[Greeting-2,SittingDown-2,Waiting-1]' in test set.
            kind:
                Keypoint format, 'mpii' or 'human36m'
            ignore_cameras:
                A list with indices of cameras to exclude (0 to 3 inclusive)
        """
        assert train or test, '`Human36MMultiViewDataset` must be constructed with at least ' \
                              'one of `test=True` / `train=True`'
        assert kind in ("mpii", "human36m")

        self.root = root
        self.labels_path = labels_path
        self.image_shape = None if image_shape is None else tuple(image_shape)
        self.scale_bbox = scale_bbox
        self.norm_image = norm_image
        self.cuboid_size = cuboid_size
        self.kind = kind
        self.undistort_images = undistort_images
        self.ignore_cameras = ignore_cameras
        self.crop = crop

        self.labels = np.load(labels_path, allow_pickle=True).item()

        n_cameras = len(self.labels['camera_names'])
        assert all(camera_idx in range(n_cameras) for camera_idx in self.ignore_cameras)

        train_subjects = ['S1', 'S5', 'S6', 'S7', 'S8']
        test_subjects = ['S9', 'S11']
        
        if subject is not None:
            if subject in train_subjects:
                train, test = True, False
                train_subjects = [subject]
            elif subject in test_subjects:
                train, test = False, True
                test_subjects = [subject]

        train_subjects = list(self.labels['subject_names'].index(x) for x in train_subjects)
        test_subjects  = list(self.labels['subject_names'].index(x) for x in test_subjects)

        indices = []
        if train:
            mask = np.isin(self.labels['table']['subject_idx'], train_subjects, assume_unique=True)
            indices.append(np.nonzero(mask)[0])
        if test:
            mask = np.isin(self.labels['table']['subject_idx'], test_subjects, assume_unique=True)

            if not with_damaged_actions:
                mask_S9 = self.labels['table']['subject_idx'] == self.labels['subject_names'].index('S9')

                damaged_actions = 'Greeting-2', 'SittingDown-2', 'Waiting-1'
                damaged_actions = [self.labels['action_names'].index(x) for x in damaged_actions]
                mask_damaged_actions = np.isin(self.labels['table']['action_idx'], damaged_actions)

                mask &= ~(mask_S9 & mask_damaged_actions)

            indices.append(np.nonzero(mask)[0][::retain_every_n_frames_in_test])

        self.labels['table'] = self.labels['table'][np.concatenate(indices)]

        self.num_keypoints = 16 if kind == "mpii" else 17
        assert self.labels['table']['keypoints'].shape[1] == 17, "Use a newer 'labels' file"

        self.keypoints_3d_pred = None
        if pred_results_path is not None and False:
            pred_results = np.load(pred_results_path, allow_pickle=True)
            keypoints_3d_pred = pred_results['keypoints_3d'][np.argsort(pred_results['indexes'])]
            self.keypoints_3d_pred = keypoints_3d_pred[::retain_every_n_frames_in_test]
            assert len(self.keypoints_3d_pred) == len(self), \
                f"[train={train}, test={test}] {labels_path} has {len(self)} samples, but '{pred_results_path}' " + \
                f"has {len(self.keypoints_3d_pred)}. Did you follow all preprocessing instructions carefully?"

    def __len__(self):
        return len(self.labels['table'])

    def __getitem__(self, idx):
        sample = defaultdict(list) # return value
        shot = self.labels['table'][idx]
        # 3D keypoints
        # add dummy confidences
        sample['keypoints_3d'] = np.pad(
            shot['keypoints'][:self.num_keypoints],
            ((0,0), (0,1)), 'constant', constant_values=1.0)

        sample.default_factory = None
        return sample


class Human36MMultiViewDataset(Dataset):
    """
        Human3.6M for multiview tasks.
    """
    def __init__(self,
                 root='/Vol1/dbstore/datasets/Human3.6M/processed/',
                 labels_path='/Vol1/dbstore/datasets/Human3.6M/extra/human36m-multiview-labels-SSDbboxes.npy',
                 pred_results_path=None,
                 image_shape=(192, 256),
                 train=False,
                 test=False,
                 retain_every_n_frames_in_test=1,
                 with_damaged_actions=False,
                 cuboid_size=2000.0,
                 scale_bbox=1.5,
                 norm_image=True,
                 kind="mpii",
                 undistort_images=False,
                 ignore_cameras=[],
                 crop=True,
                 erase=False,
                 data_format=''
                 ):
        """
            root:
                Path to 'processed/' directory in Human3.6M
            labels_path:
                Path to 'human36m-multiview-labels.npy' generated by 'generate-labels-npy-multiview.py'
                from https://github.sec.samsung.net/RRU8-VIOLET/human36m-preprocessing
            retain_every_n_frames_in_test:
                By default, there are 159 181 frames in training set and 26 634 in test (val) set.
                With this parameter, test set frames will be evenly skipped frames so that the
                test set size is `26634 // retain_every_n_frames_in_test`.
                Use a value of 13 to get 2049 frames in test set.
            with_damaged_actions:
                If `True`, will include 'S9/[Greeting-2,SittingDown-2,Waiting-1]' in test set.
            kind:
                Keypoint format, 'mpii' or 'human36m'
            ignore_cameras:
                A list with indices of cameras to exclude (0 to 3 inclusive)
        """
        assert train or test, '`Human36MMultiViewDataset` must be constructed with at least ' \
                              'one of `test=True` / `train=True`'
        assert kind in ("mpii", "human36m")

        self.root = root
        self.labels_path = labels_path
        self.image_shape = None if image_shape is None else tuple(image_shape)
        self.test = test
        self.scale_bbox = scale_bbox
        self.norm_image = norm_image
        self.cuboid_size = cuboid_size
        self.kind = kind
        self.undistort_images = undistort_images
        self.ignore_cameras = ignore_cameras
        self.crop = crop
        self.erase = erase
        self.data_format = data_format
        self.actual_joints = {
            0: "rank",
            1: "rkne",
            2: "rhip",
            3: "lhip",
            4: "lkne",
            5: "lank",
            6: "root",
            7: "belly",
            8: "neck",
            9: "head",
            10: "rwri",
            11: "relb",
            12: "rsho",
            13: "lsho",
            14: "lelb",
            15: "lwri",
            16: "nose"
            }
        self.union_joints = {
            0: 'root',
            1: 'rhip',
            2: 'rkne',
            3: 'rank',
            4: 'lhip',
            5: 'lkne',
            6: 'lank',
            7: 'belly',
            8: 'neck',
            9: 'nose',
            10: 'head',
            11: 'lsho',
            12: 'lelb',
            13: 'lwri',
            14: 'rsho',
            15: 'relb',
            16: 'rwri'
        }
        self.u2a_mapping = self.get_mapping()

        # self.labels = np.load(labels_path, allow_pickle=True).item()
        with open(labels_path, 'rb') as f:  
            self.labels = pickle.loads(f.read())

        self.keypoints_3d_pred = None

    def get_mapping(self):
        union_keys = list(self.union_joints.keys())
        union_values = list(self.union_joints.values())

        mapping = {k: '*' for k in union_keys}
        for k, v in self.actual_joints.items():
            idx = union_values.index(v)
            key = union_keys[idx]
            mapping[key] = k
        return mapping
        
    def __len__(self):
        # return len(self.labels['table'])
        return len(self.labels)

    def __getitem__(self, idx):
        shot = self.labels[idx]
        
        # load image
        image_dir = self.root
        subdir_format = 's_{:02d}_act_{:02d}_subact_{:02d}_ca_{:02d}'
        subdir = subdir_format.format(shot['subject'], shot['action'], shot['subaction'], shot['camera_id']+1)
        image_format = 's_{:02d}_act_{:02d}_subact_{:02d}_ca_{:02d}_{:06d}.jpg'
        imagename = image_format.format(shot['subject'], shot['action'], shot['subaction'], shot['camera_id']+1, shot['image_id'])
        image_path = os.path.join(subdir, imagename)

        image = cv2.imread(
            os.path.join(image_dir, image_path), cv2.IMREAD_COLOR | cv2.IMREAD_IGNORE_ORIENTATION
            )#[..., ::-1]#.astype('float32')

        if self.crop:
            # crop image
            image = crop_image(image, shot['center'], shot['scale'], self.image_shape) # (256, 192, 3) uint8

        # return image, np.expand_dims(shot['joints_3d'], axis=0), shot['joints_2d_gt'], shot['joints_2d_gt_crop']
        # return np.expand_dims(shot['joints_3d'], axis=0), shot['joints_2d_cpn'], shot['joints_2d_cpn_crop']
        return image, np.expand_dims(shot['joints_3d'], axis=0), shot['joints_2d_cpn'], shot['joints_2d_cpn_crop']

    def evaluate_using_per_pose_error(self, per_pose_error, split_by_subject):
        def evaluate_by_actions(self, per_pose_error, mask=None):
            if mask is None:
                mask = np.ones_like(per_pose_error, dtype=bool)

            action_scores = {
                'Average': {'total_loss': per_pose_error[mask].sum(), 'frame_count': np.count_nonzero(mask)}
            }

            # labels_action_idx = (np.array([label['action'] for label in self.labels])-2) * 2 + \
            #                     (np.array([label['subaction'] for label in self.labels])-1)

            for action_idx in range(len(retval['action_names'])):
                # action_mask = (self.labels['table']['action_idx'] == action_idx) & mask
                action_mask = (self.labels_action_idx == action_idx) & mask
                action_per_pose_error = per_pose_error[action_mask]
                # action_scores[self.labels['action_names'][action_idx]] = {
                action_scores[retval['action_names'][action_idx]] = {
                    'total_loss': action_per_pose_error.sum(), 'frame_count': len(action_per_pose_error)
                }

            action_names_without_trials = \
                [name[:-2] for name in retval['action_names'] if name.endswith('-1')]

            for action_name_without_trial in action_names_without_trials:
                combined_score = {'total_loss': 0.0, 'frame_count': 0}

                for trial in 1, 2:
                    action_name = '%s-%d' % (action_name_without_trial, trial)
                    combined_score['total_loss' ] += action_scores[action_name]['total_loss']
                    combined_score['frame_count'] += action_scores[action_name]['frame_count']
                    del action_scores[action_name]

                action_scores[action_name_without_trial] = combined_score

            for k, v in action_scores.items():
                action_scores[k] = float('nan') if v['frame_count'] == 0 else (v['total_loss'] / v['frame_count'])

            return action_scores

        subject_scores = {
            'Average': evaluate_by_actions(self, per_pose_error)
        }
        
        # for subject_idx in range(len(self.labels['subject_names'])):
        for subject_idx in range(len(retval['subject_names'])):
            # subject_mask = self.labels['table']['subject_idx'] == subject_idx
            subject_mask = self.labels_subject_idx == subject_idx
            # subject_scores[self.labels['subject_names'][subject_idx]] = \
            subject_scores[retval['subject_names'][subject_idx]] = \
                evaluate_by_actions(self, per_pose_error, subject_mask)

        return subject_scores

    def evaluate_using_pred(self, keypoints_gt, keypoints_3d_predicted):
        def evaluate_by_actions(self, keypoints_gt, keypoints_3d_predicted, mask=None):
            if mask is None:
                mask = np.ones(keypoints_gt.shape[0], dtype=bool)

            e1 = MPJPE()
            e2 = P_MPJPE()
            e3 = N_MPJPE()
            ev = MPJVE()

            action_scores = {}

            for action_idx in range(len(retval['action_names'])):
                action_mask = (self.labels_action_idx == action_idx) & mask
                frame_count = np.count_nonzero(action_mask)
                loss_3d_pos = frame_count * e1(keypoints_3d_predicted[action_mask], keypoints_gt[action_mask]).item()
                loss_3d_pos_procrustes = frame_count * e2(keypoints_3d_predicted[action_mask].squeeze().cpu().numpy(), keypoints_gt[action_mask].squeeze().cpu().numpy())
                # loss_3d_pos_scale = frame_count * e3(keypoints_3d_predicted[action_mask], keypoints_gt[action_mask]).item()
                loss_3d_vel = frame_count * ev(keypoints_3d_predicted[action_mask].squeeze().cpu().numpy(), keypoints_gt[action_mask].squeeze().cpu().numpy())

                action_scores[retval['action_names'][action_idx]] = {
                    'MPJPE': loss_3d_pos,
                    'P_MPJPE': loss_3d_pos_procrustes,
                    # 'N_MPJPE': loss_3d_pos_scale,
                    'MPJVE': loss_3d_vel,
                    'frame_count': frame_count
                }

            action_names_without_trials = \
                [name[:-2] for name in retval['action_names'] if name.endswith('-1')]

            for action_name_without_trial in action_names_without_trials:
                combined_score = {
                    'MPJPE': 0.0,
                    'P_MPJPE': 0.0,
                    # 'N_MPJPE': 0.0,
                    'MPJVE': 0.0,
                    'frame_count': 0,
                }

                for trial in 1, 2:
                    action_name = '%s-%d' % (action_name_without_trial, trial)
                    combined_score['MPJPE' ] += action_scores[action_name]['MPJPE']
                    combined_score['P_MPJPE' ] += action_scores[action_name]['P_MPJPE']
                    # combined_score['N_MPJPE' ] += action_scores[action_name]['N_MPJPE']
                    combined_score['MPJVE' ] += action_scores[action_name]['MPJVE']
                    combined_score['frame_count'] += action_scores[action_name]['frame_count']
                    del action_scores[action_name]

                action_scores[action_name_without_trial] = combined_score

            for k in action_scores.keys():
                frame_count = action_scores[k]['frame_count']
                action_scores[k] = {
                    'MPJPE': action_scores[k]['MPJPE'] / frame_count,
                    'P_MPJPE': action_scores[k]['P_MPJPE'] / frame_count,
                    'MPJVE': action_scores[k]['MPJVE'] / frame_count,
                    # 'N_MPJPE': action_scores[k]['N_MPJPE'] / frame_count
                }

            return action_scores

        action_scores = evaluate_by_actions(self, keypoints_gt, keypoints_3d_predicted)

        return action_scores

    def evaluate(self, keypoints_gt, keypoints_3d_predicted, proj_matricies_batch=None, config=None,  split_by_subject=False, transfer_cmu_to_human36m=False, transfer_human36m_to_human36m=False):
        np.savez("files.npz", keypoints_3d_predicted.cpu().numpy(), self.video_idx)
        #keypoints_gt = self.labels['table']['keypoints'][:, :self.num_keypoints]
        if keypoints_3d_predicted.shape != keypoints_gt.shape:
            raise ValueError(
                '`keypoints_3d_predicted` shape should be %s, got %s' % \
                (keypoints_gt.shape, keypoints_3d_predicted.shape))


        result = self.evaluate_using_pred(keypoints_gt, keypoints_3d_predicted)

        return result
        # return result['per_pose_error_relative']['Average']['Average'], result

    def evaluate_2d_joint(self, pred, gt, headsize, threshold):
        distance = np.sqrt(np.sum((gt - pred)**2, axis=2))
        detected = (distance <= headsize * threshold)
    
        joint_detection_rate = np.sum(detected, axis=0) / np.float(gt.shape[0])

        name_values = collections.OrderedDict()
        joint_names = self.actual_joints
        for i in range(self.num_keypoints):
            name_values[joint_names[self.u2a_mapping[i]]] = joint_detection_rate[self.u2a_mapping[i]]  

        return name_values, np.mean(joint_detection_rate)

    def evaluate2d(self, keypoints_2d_gt, keypoints_2d_pred, thresholds, config, split_by_subject=False, transfer_cmu_to_human36m=False, transfer_human36m_to_human36m=False):
        # keypoints_2d_gt: (b, n_views, 17, 2)
        headsize = config.model.image_shape[0] / 10.0
        subjects = self.labels['table']['subject_idx']

        gt = keypoints_2d_gt.reshape(-1, self.num_keypoints, 2)
        pred = keypoints_2d_pred.reshape(-1, self.num_keypoints, 2)


        name_values_dict = {}
        mean_rate_dict = {}
        for thres in thresholds:
            # all
            name_values, mean_rate = self.evaluate_2d_joint(pred, gt, headsize, thres)   

            if split_by_subject:
                # S9
                name_values_s9, mean_rate_s9 = self.evaluate_2d_joint(pred[:5012], gt[:5012], headsize, thres)   

                # S11
                name_values_s11, mean_rate_s11 = self.evaluate_2d_joint(pred[5012:], gt[5012:], headsize, thres)   

                name_values_dict.update({thres: {'all': name_values, 's9': name_values_s9, 's11': name_values_s11}})
                mean_rate_dict.update({thres: {'all': mean_rate, 's9': mean_rate_s9, 's11': mean_rate_s11}})
            else:
                name_values_dict.update({thres: {'all': name_values}})
                mean_rate_dict.update({thres: {'all': mean_rate}})

        return name_values_dict, mean_rate_dict


class Human36MSingleViewDataset(Human36MMultiViewDataset):
    """
        Human3.6M for single view validation.
    """
    def __init__(self,
                 root='/Vol1/dbstore/datasets/Human3.6M/processed/',
                 labels_path='/Vol1/dbstore/datasets/Human3.6M/extra/human36m-multiview-labels-SSDbboxes.npy',
                 pred_results_path=None,
                 image_shape=(192, 256),
                 train=False,
                 test=False,
                 retain_every_n_frames_in_test=1,
                 with_damaged_actions=False,
                 cuboid_size=2000.0,
                 scale_bbox=1.5,
                 norm_image=True,
                 kind="mpii",
                 undistort_images=False,
                 ignore_cameras=[],
                 crop=True,
                 erase=False,
                 rank = None,
                 world_size = None,
                 data_format=''
                 ):
        super(Human36MSingleViewDataset, self).__init__(
            root=root,
            labels_path=labels_path,
            pred_results_path=pred_results_path,
            image_shape=image_shape,
            train=train,
            test=test,
            retain_every_n_frames_in_test=retain_every_n_frames_in_test,
            with_damaged_actions=with_damaged_actions,
            cuboid_size=cuboid_size,
            scale_bbox=scale_bbox,
            norm_image=norm_image,
            kind=kind,
            undistort_images=undistort_images,
            ignore_cameras=ignore_cameras,
            crop=crop,
            erase=erase,
            data_format=data_format
        )

        self.pred_results_path = pred_results_path
        self.labels_action_idx = (np.array([label['action'] for label in self.labels])-2) * 2 + \
                                 (np.array([label['subaction'] for label in self.labels])-1)
        self.labels_subject_idx = np.array([retval['subject_names'].index('S'+str(label['subject'])) for label in self.labels])
        self.dist_size = self.prepare_labels(rank, world_size)
        self.video_idx = np.array([label['video_id'] for label in self.labels])


    def prepare_labels(self, rank, world_size):
        if rank is not None and world_size is not None:
            n = len(self.labels) // world_size
            # n = len(self.labels['table']) // world_size
            # dist_size = [n if i < world_size - 1 else len(self.labels['table']) - n * (world_size - 1)\
            dist_size = [n if i < world_size - 1 else len(self.labels) - n * (world_size - 1)\
                for i in range(world_size)]
            start = n * rank
            end = len(self.labels) if rank == world_size - 1 else start + n
            # end = len(self.labels['table']) if rank == world_size - 1 else start + n
            # self.labels['table'] = self.labels['table'][start:end]
            self.labels = self.labels[start:end]
            if self.keypoints_3d_pred is not None:
                self.keypoints_3d_pred = self.keypoints_3d_pred[start:end]
            # self.camera_idxes = self.camera_idxes[start:end]

            return dist_size

    def __getitem__(self, idx):
        shot = self.labels[idx]

        # load image
        image_dir = self.root
        subdir_format = 's_{:02d}_act_{:02d}_subact_{:02d}_ca_{:02d}'
        subdir = subdir_format.format(shot['subject'], shot['action'], shot['subaction'], shot['camera_id']+1)
        image_format = 's_{:02d}_act_{:02d}_subact_{:02d}_ca_{:02d}_{:06d}.jpg'
        imagename = image_format.format(shot['subject'], shot['action'], shot['subaction'], shot['camera_id']+1, shot['image_id'])
        image_path = os.path.join(subdir, imagename)

        image = cv2.imread(
            os.path.join(image_dir, image_path), cv2.IMREAD_COLOR | cv2.IMREAD_IGNORE_ORIENTATION
            )#[..., ::-1]#.astype('float32')

        if self.crop:
            # crop image
            image = crop_image(image, shot['center'], shot['scale'], self.image_shape) # (256, 192, 3) uint8

        # if self.norm_image:
        #     image = normalize_image(image)

        # keypoints_2d_cpn = shot['joints_2d_cpn']#.astype('float32')
        # keypoints_2d_cpn_crop = shot['joints_2d_cpn_crop']#.astype('float32')

        # keypoints_3d_gt = shot['joints_3d']#.astype('float32')
        # keypoints_3d_gt[1:] -= keypoints_3d_gt[:1]
        # keypoints_3d_gt[0] = 0

        # return image, np.expand_dims(shot['joints_3d'], axis=0), shot['joints_2d_gt'], shot['joints_2d_gt_crop']
        return image, np.expand_dims(shot['joints_3d'], axis=0), shot['joints_2d_cpn'], shot['joints_2d_cpn_crop']
        # return np.expand_dims(shot['joints_3d'], axis=0), shot['joints_2d_cpn'], shot['joints_2d_cpn_crop']



